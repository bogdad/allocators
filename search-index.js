var searchIndex = {};
searchIndex['allocators'] = {"items":[[3,"AllocBox","allocators","An item allocated by a custom allocator.",null,null],[3,"Place","","A place for allocating into.\nThis is only used for in-place allocation,\ne.g. `let val = in (alloc.make_place().unwrap()) { EXPR }`",null,null],[3,"Block","","A block of memory created by an allocator.",null,null],[3,"HeapAllocator","","Allocator stub that just forwards to heap allocation.\nIt is recommended to use the `HEAP` constant instead\nof creating a new instance of this, to benefit from\nthe static lifetime that it provides.",null,null],[4,"Error","","Errors that can occur while creating an allocator\nor allocating from it.",null,null],[13,"OutOfMemory","","The allocator failed to allocate the amount of memory requested of it.",0,null],[13,"UnsupportedAlignment","","The allocator does not support the requested alignment.",0,null],[13,"AllocatorSpecific","","An allocator-specific error message.",0,null],[11,"take","","Consumes this allocated value, yielding the value it manages.",1,{"inputs":[{"name":"allocbox"}],"output":{"name":"t"}}],[11,"as_block","","Gets a handle to the block of memory this manages.",1,{"inputs":[{"name":"allocbox"}],"output":{"name":"block"}}],[11,"deref","","",1,{"inputs":[{"name":"allocbox"}],"output":{"name":"t"}}],[11,"deref_mut","","",1,{"inputs":[{"name":"allocbox"}],"output":{"name":"t"}}],[11,"downcast","","Attempts to downcast this `AllocBox` to a concrete type.",1,{"inputs":[{"name":"allocbox"}],"output":{"name":"result"}}],[11,"borrow","","",1,{"inputs":[{"name":"allocbox"}],"output":{"name":"t"}}],[11,"borrow_mut","","",1,{"inputs":[{"name":"allocbox"}],"output":{"name":"t"}}],[11,"drop","","",1,{"inputs":[{"name":"allocbox"}],"output":null}],[11,"make_place","","",2,{"inputs":[{"name":"place"}],"output":{"name":"self"}}],[11,"finalize","","",2,{"inputs":[{"name":"place"}],"output":{"name":"owner"}}],[11,"pointer","","",2,null],[11,"drop","","",2,{"inputs":[{"name":"place"}],"output":null}],[0,"composable","","This module contains some composable building blocks to build allocator chains.",null,null],[3,"NullAllocator","allocators::composable","This allocator always fails.\nIt will panic if you try to deallocate with it.",null,null],[3,"Fallback","","This allocator has a main and a fallback allocator.\nIt will always attempt to allocate first with the main allocator,\nand second with the fallback.",null,null],[3,"Proxy","","This wraps an allocator and a logger, logging all allocations\nand deallocations.",null,null],[8,"ProxyLogger","","Something that logs an allocator's activity.\nIn practice, this may be an output stream,\na data collector, or seomthing else entirely.",null,null],[10,"allocate_success","","Called after a successful allocation.",3,{"inputs":[{"name":"proxylogger"},{"name":"block"}],"output":null}],[10,"allocate_fail","","Called after a failed allocation.",3,{"inputs":[{"name":"proxylogger"},{"name":"error"},{"name":"usize"},{"name":"usize"}],"output":null}],[10,"deallocate","","Called when deallocating a block.",3,{"inputs":[{"name":"proxylogger"},{"name":"block"}],"output":null}],[10,"reallocate_success","","Called after a successful reallocation.",3,{"inputs":[{"name":"proxylogger"},{"name":"block"},{"name":"block"}],"output":null}],[10,"reallocate_fail","","Called after a failed reallocation.",3,{"inputs":[{"name":"proxylogger"},{"name":"error"},{"name":"block"},{"name":"usize"}],"output":null}],[11,"allocate_raw","","",4,{"inputs":[{"name":"nullallocator"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"reallocate_raw","","",4,{"inputs":[{"name":"nullallocator"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[11,"deallocate_raw","","",4,{"inputs":[{"name":"nullallocator"},{"name":"block"}],"output":null}],[11,"owns_block","","",4,{"inputs":[{"name":"nullallocator"},{"name":"block"}],"output":{"name":"bool"}}],[11,"new","","Create a new `Fallback`",5,{"inputs":[{"name":"fallback"},{"name":"m"},{"name":"f"}],"output":{"name":"self"}}],[11,"allocate_raw","","",5,{"inputs":[{"name":"fallback"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"reallocate_raw","","",5,{"inputs":[{"name":"fallback"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[11,"deallocate_raw","","",5,{"inputs":[{"name":"fallback"},{"name":"block"}],"output":null}],[11,"owns_block","","",5,{"inputs":[{"name":"fallback"},{"name":"block"}],"output":{"name":"bool"}}],[11,"new","","Create a new proxy allocator.",6,{"inputs":[{"name":"proxy"},{"name":"a"},{"name":"l"}],"output":{"name":"self"}}],[11,"allocate_raw","","",6,{"inputs":[{"name":"proxy"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"reallocate_raw","","",6,{"inputs":[{"name":"proxy"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[11,"deallocate_raw","","",6,{"inputs":[{"name":"proxy"},{"name":"block"}],"output":null}],[0,"freelist","allocators","A Free List allocator.",null,null],[3,"FreeList","allocators::freelist","A `FreeList` allocator manages a list of free memory blocks of uniform size.\nWhenever a block is requested, it returns the first free block.",null,null],[11,"new","","Creates a new `FreeList` backed by the heap. `block_size` must be greater\nthan or equal to the size of a pointer.",7,{"inputs":[{"name":"freelist"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"new_from","","Creates a new `FreeList` backed by another allocator. `block_size` must be greater\nthan or equal to the size of a pointer.",7,{"inputs":[{"name":"freelist"},{"name":"a"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"allocate_raw","","",7,{"inputs":[{"name":"freelist"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"reallocate_raw","","",7,{"inputs":[{"name":"freelist"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[11,"deallocate_raw","","",7,{"inputs":[{"name":"freelist"},{"name":"block"}],"output":null}],[11,"drop","","",7,{"inputs":[{"name":"freelist"}],"output":null}],[0,"scoped","allocators","A scoped linear allocator. This is something of a cross between a stack allocator\nand a traditional linear allocator.",null,null],[3,"Scoped","allocators::scoped","A scoped linear allocator.",null,null],[11,"new","","Creates a new `Scoped` backed by `size` bytes from the heap.",8,{"inputs":[{"name":"scoped"},{"name":"usize"}],"output":{"name":"result"}}],[11,"new_from","","Creates a new `Scoped` backed by `size` bytes from the allocator supplied.",8,{"inputs":[{"name":"scoped"},{"name":"a"},{"name":"usize"}],"output":{"name":"result"}}],[11,"scope","","Calls the supplied function with a new scope of the allocator.",8,{"inputs":[{"name":"scoped"},{"name":"f"}],"output":{"name":"result"}}],[11,"is_scoped","","",8,{"inputs":[{"name":"scoped"}],"output":{"name":"bool"}}],[11,"allocate_raw","","",8,{"inputs":[{"name":"scoped"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"reallocate_raw","","Because of the way this allocator is designed, reallocating a block that is not\nthe most recent will lead to fragmentation.",8,{"inputs":[{"name":"scoped"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[11,"deallocate_raw","","",8,{"inputs":[{"name":"scoped"},{"name":"block"}],"output":null}],[11,"owns_block","","",8,{"inputs":[{"name":"scoped"},{"name":"block"}],"output":{"name":"bool"}}],[11,"drop","","Drops the `Scoped`",8,{"inputs":[{"name":"scoped"}],"output":null}],[17,"HEAP","allocators","",null,null],[8,"Allocator","","A custom memory allocator.",null,null],[11,"allocate","","Attempts to allocate the value supplied to it.",9,{"inputs":[{"name":"allocator"},{"name":"t"}],"output":{"name":"result"}}],[11,"make_place","","Attempts to create a place to allocate into.\nFor the general purpose, calling `allocate` on the allocator is enough.\nHowever, when you know the value you are allocating is too large\nto be constructed on the stack, you should use in-place allocation.",9,{"inputs":[{"name":"allocator"}],"output":{"name":"result"}}],[10,"allocate_raw","","Attempt to allocate a block of memory.",9,{"inputs":[{"name":"allocator"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[10,"reallocate_raw","","Reallocate a block of memory.",9,{"inputs":[{"name":"allocator"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[10,"deallocate_raw","","Deallocate the memory referred to by this block.",9,{"inputs":[{"name":"allocator"},{"name":"block"}],"output":null}],[8,"BlockOwner","","An allocator that knows which blocks have been issued by it.",null,null],[11,"owns","","Whether this allocator owns this allocated value.",10,{"inputs":[{"name":"blockowner"},{"name":"allocbox"}],"output":{"name":"bool"}}],[10,"owns_block","","Whether this allocator owns the block passed to it.",10,{"inputs":[{"name":"blockowner"},{"name":"block"}],"output":{"name":"bool"}}],[11,"with_fallback","","Joins this allocator with a fallback allocator.",10,{"inputs":[{"name":"blockowner"},{"name":"o"}],"output":{"name":"fallback"}}],[11,"new","","Create a new block from the supplied parts.\nThe pointer cannot be null.",11,null],[11,"empty","","Creates an empty block.",11,{"inputs":[{"name":"block"}],"output":{"name":"self"}}],[11,"ptr","","Get the pointer from this block.",11,null],[11,"size","","Get the size of this block.",11,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"align","","Get the align of this block.",11,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"is_empty","","Whether this block is empty.",11,{"inputs":[{"name":"block"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"fmt","","",12,{"inputs":[{"name":"heapallocator"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"allocate_raw","","",12,{"inputs":[{"name":"heapallocator"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"reallocate_raw","","",12,{"inputs":[{"name":"heapallocator"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[11,"deallocate_raw","","",12,{"inputs":[{"name":"heapallocator"},{"name":"block"}],"output":null}],[11,"allocate_raw","alloc::boxed","",13,{"inputs":[{"name":"box"},{"name":"usize"},{"name":"usize"}],"output":{"name":"result"}}],[11,"reallocate_raw","","",13,{"inputs":[{"name":"box"},{"name":"block"},{"name":"usize"}],"output":{"name":"result"}}],[11,"deallocate_raw","","",13,{"inputs":[{"name":"box"},{"name":"block"}],"output":null}]],"paths":[[4,"Error"],[3,"AllocBox"],[3,"Place"],[8,"ProxyLogger"],[3,"NullAllocator"],[3,"Fallback"],[3,"Proxy"],[3,"FreeList"],[3,"Scoped"],[8,"Allocator"],[8,"BlockOwner"],[3,"Block"],[3,"HeapAllocator"],[3,"Box"]]};
initSearch(searchIndex);
